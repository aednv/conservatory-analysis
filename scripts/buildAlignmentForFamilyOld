#!/usr/bin/perl

use POSIX;
use strict;
use warnings;
use Text::CSV;
use Data::Dumper qw(Dumper);
use List::Util qw(min max sum);
use List::MoreUtils qw(uniq firstidx);
use Bio::Kmer;
use String::Diff;
use Cwd;
use Getopt::Long;
use experimental 'smartmatch';

################################################################################
###### utility functions #######################################################
sub mean {
    return sum(@_)/@_;
}

# Simple mask.

sub maskseq {
	my ($seq) = @_;
	$seq =~ s/[A|T]{10}/XXXXXXXXXX/g;
	return ($seq);
}

sub extractFasta {
	my ($fastaFileName, $locus) = @_;
	my $seq="";
	open (my $fastaFile, "<" , $fastaFileName) || die "Cannot open file $fastaFile.\n";
	while((my $line = <$fastaFile>) && $seq eq "") {
		chomp($line);
		if( $line eq ">$locus") {
			$seq = <$fastaFile>;
			chomp($seq);
			$seq = maskseq($seq);
		} else { $line = <$fastaFile>; } 
	}
	close($fastaFile);
	return($seq);
}

################################################################################
######### Setup

my $conservatoryDir=abs_path(".");
my $locus;
my $family;
my $MIN_QUALITY = 0; # the minimum alignment quality score from vista to be consideted a legit alignment
my $MIN_ALIGNMENTS = 4; # The minimum number of aligned promoters that is required to generate a MAF file
my $IDENTITY= 60;
my $KEEP_TMP = 0;
my $VERBOSE = 0;
my $DUMP_SAM = 0;
my $help = 0;

########### Parameters
my $upstreamLength;
my $downstreamLength;
my $maffilterDir;



GetOptions ("conservatoryDirectory=s" => \$conservatoryDir,
			"locus=s" => \$locus,
			"family=s" => \$family,
			"identity=i" => \$IDENTITY,
			"keep-tmp" => \$KEEP_TMP,
			"verbose" => \$VERBOSE,
			"dump-sam" => \$DUMP_SAM,
			"help" => \$help) or die ("Error in command line arguments\n");
			

if( $locus eq "" or $family eq "" or $help) {
	print "Conservatory version 0.0.1\n\n";

   print "buildAlignmentForFamily --conservatoryDirectory <dir> --family <familyName> --locus <Locus>";
   print "\t--family\tFamily name (MANDATORY).\n";
   print "\t--locus\t\t\tLocus in the reference genome for the family (MANDATORY).\n";
   print "\t--identity\t\tMinimum identity for LASTZ alignments. Default is 60. Use lower number if species are more distant.\n";
   print "\t--keep-tmp\t\tDo not delete all the temporary files produced in the TMP directory.\n";
   print "\t--dump-sam\t\tExport a sam of all pair-wise alignment, translated to absoluted coordinates. For JBrowse tracks.\n";
   print "\t--verbose\t\tOutput extra progress messages.\n";
   print "\t--help\t\t\tPrints this message.\n\n";
   print "\nRequired Environment variables:\n\tTMP\t\tTemporary directory\n\tAVID\t\tLocation of avid aligner\n";
   print "\n\nMAFFILTER\t\tmafFileter directory\n\n";
   
   exit();
}


### Set up directory and file access
my $genomedbFile = $conservatoryDir . "/genome_database.csv";
my $parameterFile = $conservatoryDir . "/conservatory.parameters.txt";
my $outputDir = "$conservatoryDir/alignments/$family/";
my $tmpDir = "$conservatoryDir/alignments/$family/tmp";
my $maffilterDir;
my $avidDir;

####### First, sanity checks. Check to see if directory structure is OK and if programs are installed
####### 
die "ERROR: Cannot find file genome database file ($genomedbFile)\n" unless -e $genomedbFile;
die "ERROR: Cannot find file conservatory parameter file ($parameterFile)\n" unless -e $parameterFile;
die "ERROR: Conservatory directory structure at ($conservatoryDir) is corrupt\n" unless (-e "$conservatoryDir/genomes" && -e "$conservatoryDir/genomes/blastdb/" && -e "$conservatoryDir/scripts" && -e "$conservatoryDir/alignments");

my $t_multiz = `sh -c 'command -v multiz'`;
die "ERROR: Cannot find multiz in path. Please make sure it is installed.\n" unless ($t_multiz ne "");  

my $t_lastz = `sh -c 'command -v lastz'`;
die "ERROR: Cannot find lastz in path. Please make sure it is installed.\n" unless ($t_lastz ne "");  

##################### Read Parameters
if($verbose) { print localtime(). ": Loading parameter file $parameterFile.\n"; }
open (my $parameters, "<", $parameterFile);
while(my $curline = <$parameters>) {
	chomp($curline);
	if(substr($curline,1,1) ne "#") {
		(my $paramName, my $paramValue) = split /=/, $curline;
		if(uc($paramName) eq "UPSTREAMLENGTH") { $upstreamLength = $paramValue; }
		elsif(uc($paramName) eq "DOWNSTREAMLENGTH") { $downstreamLength = $paramValue; }
		elsif(uc($paramName) eq "MAFFILTERDIRECTORY") { $maffilterDir = $paramValue; }
		elsif(uc($paramName) eq "AVIDDIRECTORY") { $avidDir = $paramValue; }
		elsif($paramName ne "") { print localtime() . ": WARNING Unknown parameter $paramName.\n"; }
	}
}
close($parameters);
if($verbose) { print localtime() . ": Running parameters (upstreamLength $upstreamLength; downstreamLength $downstreamLength).\n"; } 

####### Check presence of programs.

die "ERROR: Cannot find file maffilter program ($maffilterDir/maffilter)\n" unless -e "$maffilterDir/maffilter";
die "ERROR: Cannot find file avid program ($avidDir/avid-linux)\n" unless -e "$avidDir/avid-linux";

###############################################
##### Now set things up
##### Find out what is our reference genome
my $refgenome="";
open (my $genomeDatabase, "<", $genomedbFile);
my $header = <$genomeDatabase>;
while((<$genomeDatabase>) && $refgenome eq "") {
	(my $curgenome, my $curspecies, my $curfamily, my $currefgenome) = split /,/;
	if($curfamily eq $family && $curgenome eq $currefgenome) { $refgenome = $curgenome; }
}
close ($genomeDatabase);
die "ERROR: Cannot find family ($family) or the reference genome for the family in the genome database file.\n" unless $refgenome ne "";
	
####### now make sure our directories exist
if (! -e $outputDir) { mkdir($outputDir); }
if (! -e $tmpDir) { mkdir($tmpDir); }

####### Set up the reference fasta files
my $refFilenameUp = "$tmpDir/$refgenome.$locus_up.fasta";
my $refFilenameDown = "$tmpDir/$refgenome.$locus_down.fasta";
my $upstreamRefSeq = extractFasta("$conservatoryDir/genomes/$refgenome.upstream.fasta", $locus)
my $downstreamRefSeq = extractFasta("$conservatoryDir/genomes/$refgenome.downstream.fasta", $locus)

### and set up our reference sequences.
open(my $upRefFile, ">", $refFileNameUp);
print $upRefFile (">$locus.c1|$refgenome|\n$upstreamRefSeq\n");
close($upRefFile);
open(my $downRefFile, ">", $refFileNameDown);
print $downRefFile (">$locus.c1|$refgenome|\n$downstreamRefSeq\n");
close($downRefFile);


#remember where we are
my $curdir = getcwd;

# set up orthology hashes
my %orth_quality;  #Hash of alignment quality
my %orth_names; # Hash of the names for the best alignments
my %orth_species;
my %orth_fasta_names;
my %orth_fasta_down_names;

##############################################################################
# Load Genomes

open (my $genomeDatabase, "<", $genomedbFile);

my $referencegfffile;
my $referenceseq;  
my $align_ref_seq;

$header = <$genomeDatabase>;

while(<$genomedb>) {
	chomp($genomeline);
	(my $curgenome, my $curspecies, my $curfamily, my $currefgenome, my $curminquality) = split /,/;
	
	if($curgenome ne $refgenome && $curfamily eq $family) {
	}
	
	########## Process all orthologs
	open (my $orthologfile, $CONUNPE . "../allgenomes/" . $genomefields[9]) || die "Can't open ortholog file " . $genomefields[9] . "\n";
	while(my $orth_line = <$orthologfile>) {
		chomp($orth_line);
		my @ortholog_fields = split(",", $orth_line);
	
		if($ortholog_fields[0] eq $locus) {
			my $curseqname = "";
			my $curseq;
			my $align_curseq;
			my $aln_score;
			open (FASTA, $CONUNPE . "../allgenomes/" . $genomefields[6]) || die "Can't open upstream sequence file " . $genomefields[6] . "\n";
			
			while(($curseqname ne $ortholog_fields[1]) && !eof(FASTA)) {
				$curseqname = <FASTA>;
				$curseq = <FASTA>;
				chomp($curseqname);
				chomp($curseq);
				$curseqname = substr($curseqname,1);
			}
			close(FASTA);

			my $downcurseqname = "";
			my $downcurseq;

			open (DOWNFASTA, $CONUNPE . "../allgenomes/" . $genomefields[10]) || die "Can't open downstream sequence file " . $genomefields[10] . "\n";

			while(($downcurseqname ne $ortholog_fields[1]) && !eof(DOWNFASTA)) {
				$downcurseqname = <DOWNFASTA>;
				$downcurseq = <DOWNFASTA>;
				chomp($downcurseqname);
				chomp($downcurseq);
				$downcurseqname = substr($downcurseqname,1);
			}
			close(DOWNFASTA);
			
			### align the sequences
			
			########################################
			# If this is the first sequence, if it the reference sequence for the genome and all should be aligned to it
			#
			} else {
				# Upstream
				my $compfilename = $genomefields[0] . $ortholog_fields[1] . ".fasta";
				open (my $compfile, '>',  $tmpdir. $compfilename);
				print $compfile ">" . $ortholog_fields[1] . ".c1|" . $genomefields[0] . "|" . $ortholog_fields[0] . "\n" . maskseq($curseq) . "\n";
				close($compfile);
				###

				# Downstream
				my $downcompfilename = $genomefields[0] . $ortholog_fields[1] . "_down.fasta";
				open (my $downcompfile, '>',  $tmpdir . $downcompfilename);
				print $downcompfile ">" . $ortholog_fields[1] . ".c1|" . $genomefields[0] . "|" . $ortholog_fields[0] . "\n" . maskseq($downcurseq) . "\n";
				close($downcompfile);
				
				### now align the sequences
				
				chdir $tmpdir;	
				
				### Align
				system($AVID . "avid-linux -nm=both " . $reffilename . " " . $compfilename . " >/dev/null 2>/dev/null");
				
				########## Check for quality
				my $vistaoutfile = "Slreference_" . $genomefields[0] . $ortholog_fields[1];

				open (my $qualityfile, "grep Score " . $vistaoutfile . ".info |") || die ("can't open quality file");
				my $qualityline = <$qualityfile>;
				my @qualitysplit = split ' ', $qualityline;
				my $quality =  $qualitysplit[3];
				close ($qualityfile);
				if($VERBOSE) {
					print "Found ortholog for: " . $ortholog_fields[0] . " from " . $genomefields[0] . " of family " . $genomefields[$collapsefield] ." named " . $ortholog_fields[1] . " with quality " . $quality . ".\n";
				}
		
				if($quality> $genomefields[4]) {
					my @align_array;
					my @align_array_maf;
					my $gap=0;
		
					if(not exists $orth_names{$genomefields[$collapsefield]}) {

						$orth_names{$genomefields[$collapsefield]} = [ $ortholog_fields[1] ];
						$orth_species{$genomefields[$collapsefield]} = [ $genomefields[0] ];
						$orth_fasta_names{$genomefields[$collapsefield]} = [ $compfilename ];
						$orth_fasta_down_names{$genomefields[$collapsefield]} =  [ $downcompfilename ];					
						$orth_quality{$genomefields[$collapsefield]} = [ $quality ];
						
					} else {
							push( @{ $orth_names{$genomefields[$collapsefield]} }, $ortholog_fields[1]);
							push( @{ $orth_species{$genomefields[$collapsefield]} } , $genomefields[0]);
							push( @{ $orth_fasta_names{$genomefields[$collapsefield]} }, $compfilename);
							push( @{ $orth_fasta_down_names{$genomefields[$collapsefield]} }, $downcompfilename);
							push( @{ $orth_quality{$genomefields[$collapsefield]} }, $quality);
					}
				} else {
					if(!$KEEP_TMP) {
						unlink($compfilename);
						unlink($downcompfilename);
					}
				}
				
				# cleaup - remove the tmp files
				unlink ($vistaoutfile . ".info");
				unlink ($vistaoutfile . ".minfo");
				unlink ($vistaoutfile . ".out");
				
				chdir $curdir;
			}
		}
	}
}

############ Select the best genomes from the metagenome set


foreach my $curalign (keys %orth_names) {
	
		# first, check if we have a consistent duplication. if not, pick the best alignment.
		# For consistent duplication it means that the number of genes is a multiple of the number of species.
		# Then, best the best duplication group
		
		if( (scalar @{ $orth_species{$curalign} }) % (scalar uniq( @{ $orth_species{$curalign} } )) == 0 &
			 (scalar @{ $orth_species{$curalign} }) / (scalar uniq( @{ $orth_species{$curalign} } )) > 1 ) {
			my @dupspecies = uniq( @{ $orth_species{$curalign} } );
			my $bestquality = 0;
			my @bestspecies;
			foreach my $curspecies (@dupspecies) {
				my @idx = grep { @{ $orth_species{$curalign} }[$_] eq $curspecies } 0 ..(scalar @{ $orth_species{$curalign} });
				my $meanquality = mean (  @{ $orth_quality{$curalign} }[@idx] );
				if($meanquality > $bestquality) {
					$bestquality = $meanquality;
					@bestspecies = @idx;	
				}			
			}
			if($VERBOSE) {
				print "Found duplication... " . join(",", @bestspecies) . "\n";
			}

			### Remove all temporary files
			foreach my $i (0 .. ((scalar @{ $orth_quality{$curalign} })-1)) {
				if( ! ($i ~~ @bestspecies)) {
					unlink ($tmpdir . $orth_fasta_names{$curalign}[$i]);
					unlink ($tmpdir . $orth_fasta_down_names{$curalign}[$i]);					
				}
			}
			
			@{ $orth_names{$curalign} } = @{ $orth_names{$curalign} }[@bestspecies] ; 
			@{ $orth_species{$curalign} } = @{ $orth_species{$curalign} }[@bestspecies];
			@{ $orth_fasta_names{$curalign} } = @{ $orth_fasta_names{$curalign} }[@bestspecies];
			@{ $orth_fasta_down_names{$curalign} } = @{ $orth_fasta_down_names{$curalign} }[@bestspecies];					
			@{ $orth_quality{$curalign} } = @{ $orth_quality{$curalign} }[@bestspecies];		
			
		} else {
			my $topquality = max ( @{ $orth_quality{$curalign} });
			my $idx = firstidx { $_ == $topquality } @{ $orth_quality{$curalign} };
			### Remove all temporary files
			if($VERBOSE) {
				print "Picking the best one:" . $idx . "\n";
			}
			
			foreach my $i  (0.. ((scalar @{ $orth_quality{$curalign} })-1) ) {
				if($i != $idx) {
					unlink ($tmpdir . $orth_fasta_names{$curalign}[$i]);
					unlink ($tmpdir . $orth_fasta_down_names{$curalign}[$i]);
				}
			}
			$orth_names{$curalign} = [ $orth_names{$curalign}[$idx] ] ; 
			$orth_species{$curalign} = [ $orth_species{$curalign}[$idx] ];
			$orth_fasta_names{$curalign} = [ $orth_fasta_names{$curalign}[$idx] ];
			$orth_fasta_down_names{$curalign} =  [ $orth_fasta_down_names{$curalign}[$idx] ];					
			$orth_quality{$curalign} = [ $orth_quality{$curalign}[$idx] ];
		}
}
########################################################################################################
### Now, convert all hashes to arrays for alignment

my @fasta_up;
my @fasta_down;
my @orthologs;
my @species;
my @metagenomes;

foreach my $curalign (keys %orth_names) {
	push @orthologs, @{ $orth_names{$curalign} };
	push @fasta_up, @{ $orth_fasta_names{$curalign} };
	push @fasta_down, @{ $orth_fasta_down_names{$curalign} };
	push @species, @{ $orth_species{$curalign} };
	my $numOfOrthologs = (scalar @{ $orth_species{$curalign} });
	
	foreach my $i (1 .. $numOfOrthologs) {
		push (@metagenomes, $curalign);
	}
}

#################
# perform MAF alignments



my $size;
my $numOfSpecies = (scalar uniq( @species ));
my $numOfOrthologs = (scalar @orthologs);

if($VERBOSE) {
	print "Aligning all species (" . $numOfSpecies . "): " . join(",", @orthologs) . "\n";
}

if($numOfSpecies>= $MIN_ALIGNMENTS) {

	chdir $tmpdir;
	foreach my $curorth_idx (0 .. ($numOfOrthologs - 1) ) {

		system($LASTZ . "lastz --format=maf --gap=400,50 --nochain --seed=match3 --gapped --strand=both --step=1 --identity=" . $IDENTITY . " --ydrop=500 --hspthreshold=2500 --gappedthresh=2500 --inner=1800 Slreference.fasta " . $fasta_up[$curorth_idx] . " > " . $orthologs[$curorth_idx] . ".maf");
		system($LASTZ . "lastz --format=maf --gap=400,50 --nochain --seed=match3 --gapped --strand=both --step=1 --identity=" . $IDENTITY . " --ydrop=500 --hspthreshold=2500 --gappedthresh=2500 --inner=1800 Slreference_down.fasta " . $fasta_down[$curorth_idx] . " > " . $orthologs[$curorth_idx] . "_down.maf");
		if($DUMP_GTF) {
			# Dump aligned regions to gtf file
			system($CONUNPE . "gene2abs " . $CONUNPE . "../allgenomes/" . $referencegfffile . " " . $orthologs[$curorth_idx] . ".maf U " . $upstreamlen . " >>" . $TMP . "//" . $metagenomes[$curorth_idx] . ".gff");
			system($CONUNPE . "gene2abs " . $CONUNPE . "../allgenomes/" . $referencegfffile . " " . $orthologs[$curorth_idx] . "_down.maf D " . $downstreamlen . " >>" . $TMP . "//" . $metagenomes[$curorth_idx] . ".gff");
		}
		if($DUMP_SAM) {
			system($LASTZ . "lastz --format=sam --gap=400,50 --nochain --seed=match3 --gapped --strand=both --step=1 --identity=" . $IDENTITY . " --ydrop=500 --hspthreshold=2500 --gappedthresh=2500 --inner=1800 Slreference.fasta " . $fasta_up[$curorth_idx] . 			 
				" > " . $orthologs[$curorth_idx] . ".sam");
			system($LASTZ . "lastz --format=sam --gap=400,50 --nochain --seed=match3 --gapped --strand=both --step=1 --identity=" . $IDENTITY . " --ydrop=500 --hspthreshold=2500 --gappedthresh=2500 --inner=1800 Slreference_down.fasta " .  $fasta_down[$curorth_idx] . 
				" > " . $orthologs[$curorth_idx] . "_down.sam");
			system($CONUNPE . "gene2abs " . $CONUNPE . "../allgenomes/" . $referencegfffile . " " . $orthologs[$curorth_idx] . ".sam U " . $upstreamlen . " >>" . $TMP . "//" . $metagenomes[$curorth_idx] . ".sam");
			system($CONUNPE . "gene2abs " . $CONUNPE . "../allgenomes/" . $referencegfffile . " " . $orthologs[$curorth_idx] . "_down.sam D " . $downstreamlen . " >>" . $TMP . "//" . $metagenomes[$curorth_idx] . ".sam");
			
		}
		
	}


# Multiz
	# first 2
	my @okeys = keys %orth_names;
	
	system($MULTIZ . "multiz " . $orthologs[0] . ".maf " . $orthologs[1] . ".maf 1 > " . $locus . ".maf");
	foreach my $curmaf (2..($numOfOrthologs-1)) {
		system($MULTIZ . "multiz " . $locus . ".maf " . $orthologs[$curmaf] . ".maf 1 > tmp.maf");
		system("rm " . $locus . ".maf");
		system("mv tmp.maf " . $locus . ".maf");
	}
	### filter
	my $slocus = $locus;
	$slocus =~ s/\..*$//;
	my $command= ($MAFFILTER ."maffilter \"input.file=" . $tmpdir. $locus . ".maf\" \"maf.filter=Concatenate(),MinBlockLength(min_length=8),Merge(species=(" .  $slocus . "), dist_max=4),MinBlockSize(min_size=" . $MIN_ALIGNMENTS . "),EntropyFilter(species=(" .  $slocus . ")),QualFilter(species=(" .  $slocus . ")),Output(file=out.maf,compression=none)\" >/dev/null 2>/dev/null\n");

	$command =~ s/\/\//\//g;
	$command =~ s/\/\//\//g;	
	$command =~ s/\/\//\//g;	
	print $command;
	system ($command);
	system($CONUNPE . "/fixMAF " . $locus . " < out.maf | sed 's/\\.c1//' out.maf >" . $output_dir . $locus . ".maf");
	unlink("out.maf");
	unlink( $locus . ".maf");

	system($MULTIZ . "multiz " . $orthologs[0] . "_down.maf " . $orthologs[1] . "_down.maf 1 > " . $locus . "_down.maf");
	foreach my $curmaf (2..($numOfOrthologs-1)) {
		system($MULTIZ . "multiz " . $locus . "_down.maf " .  $orthologs[$curmaf] . "_down.maf 1 > tmp_down.maf");
		system("rm " . $locus . "_down.maf");
		system("mv tmp_down.maf " . $locus . "_down.maf");	
	}
	my $command= ($MAFFILTER ."maffilter \"input.file=" . $tmpdir. $locus . "_down.maf\" \"maf.filter=Concatenate(),MinBlockLength(min_length=10),Merge(species=(" .  $slocus . "), dist_max=4),MinBlockSize(min_size=" . $MIN_ALIGNMENTS . "),EntropyFilter(species=(" .  $slocus . ")),QualFilter(species=(" .  $slocus . ")),Output(file=out_down.maf,compression=none)\" >/dev/null 2>/dev/null\n");

	$command =~ s/\/\//\//g;
	$command =~ s/\/\//\//g;	
	$command =~ s/\/\//\//g;	
	system ($command);

	system($CONUNPE . "/fixMAF " . $locus . " < out_down.maf | sed 's/\\.c1//' out_down.maf >" . $output_dir . $locus . "_down.maf");
	unlink("out_down.maf");
	unlink($locus . "_down.maf");
}

chdir $curdir;
if(!$KEEP_TMP) {
	#remove FASTA leftovers
	foreach my $curorth_idx (0 .. ($numOfOrthologs - 1) ) {
		unlink($tmpdir . $fasta_up[$curorth_idx] );
		unlink($tmpdir . $fasta_down[$curorth_idx] );
		
		unlink($tmpdir . $orthologs[$curorth_idx] . ".maf");
		unlink($tmpdir . $orthologs[$curorth_idx] . "_down.maf");
		unlink($tmpdir . $orthologs[$curorth_idx] . ".sam");
		unlink($tmpdir . $orthologs[$curorth_idx] . "_down.sam");
		
		}
	unlink($tmpdir . $reffilename);
	unlink($tmpdir . $reffilename_down);
		
	rmdir($tmpdir);
}
