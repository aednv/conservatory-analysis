#!/usr/bin/perl

use POSIX;
use strict;
use Cwd 'abs_path';
use List::Util qw(min max);
use Statistics::Descriptive;
use Bio::AlignIO;
use Bio::Tools::GFF;
use Bio::SeqFeatureI;

print STDERR "\nUsage: buildCNSTables family cnsFile mapFile teGFFfile\n\nAccepts CNS and alignment map files and output generate two files:\n\n";
print STDERR "\t\t[family].cns.table.csv\t\tFiltered CNS file\n\t\t[family].cns.position.table.csv\t\tThe position of the CNS in each of the family genomes\n";
print STDERR "\n\nThe filtered CNS table has the following fields:\n";
print STDERR "\tFamily, CNS_Unique_Name, Chromosome, Start, End, ORFCheck, ConservationLevel, ConservationLevelPerLocus, PositionVariability\n\n";
print STDERR "The position table has the following fields:\n";
print STDERR "\tCNS_Unique_Name, ReferenceGene, Genome, Gene, RelativeStart, UporDown, phyloP-pvalue\n\n\n";

if(scalar @ARGV< 3) {
	die "\n\nERROR: No CNS and map file provided.\n";
}

open (my $CNSInputFile,"sort -t',' -k6,6 -k7,7n $ARGV[1] |") ||  die "ERROR: Cannot find CNS file $ARGV[1].\n";
my $family = $ARGV[0];

################### Identify the reference genome
my $refGenome="";
my $upstreamLengthReference;
my $downstreamLengthReference;
my $conservatoryDir=abs_path(".");
my $genomedbFile = $conservatoryDir . "/genome_database.csv";
open (my $genomeDatabase, "<", $genomedbFile) || die "ERROR: Cannot open genome database $genomedbFile.\n";
my $header = <$genomeDatabase>;
while((my $curgenomeline = <$genomeDatabase>) && $refGenome eq "") {
	my ($curgenomeName, $curgenomeSpecies,  $curgenomeFamily, $curgenomeReference, $upstreamLength, $downstreamLength, $geneNameField, $geneProcessingRegEx, $gene2SpeciesIdentifier, $proteinProcessingRegEx) = split /,/, $curgenomeline;
	if($curgenomeFamily eq $family && $curgenomeName eq $curgenomeReference) {
		$refGenome = $curgenomeReference;
		$upstreamLengthReference = $upstreamLength  * 1000;
		$downstreamLengthReference = $downstreamLength * 1000;
	}
}

my %CNSDB;
my $CNSCounter=1;
my @CNSList;
my %targetSpecies;
my %targetSpeciesPerLocus;

$| = 1;

######## Read the mapping file into memory
#### Now add the positions from the mapping file and index it
my %mappings;

print localtime() . ": Reading mapping file...";
open (my $mapInputFile, $ARGV[2]) ||  die "ERROR: Cannot find map file $ARGV[2].\n";
while(<$mapInputFile>) {
	chomp;
	my ($locus, $startRefRel, $length, $targetGenome,$targetLocus, $targetStartRel) = split /\t/;
	push (@ { $mappings{$locus} }, {
		'Locus' => $locus,
		'StartRefRel' => $startRefRel,
		'Length' => $length,
		'TargetGenome' => $targetGenome,
		'TargetLocus' => $targetLocus,
		'TargetStartRel' => $targetStartRel	
	});
	$targetSpecies{$targetGenome} = 1;
	$targetSpeciesPerLocus{$locus}{$targetGenome} = 1;

}

close($mapInputFile);
print "\n" . localtime() . ": Done.";

####### Load TE GFF
my $markTE=0;
my $gff;
my $gffFilename= $ARGV[3];
my $curTE;

if($gffFilename ne "") {
	if(-e $gffFilename) {
		$markTE=1;
	}
}

if($markTE) {
	print "\n" . localtime() . ": Opening TE GFF.";
	$gff = Bio::Tools::GFF->new(-file => $gffFilename,
				   -gff_version => 3);
	$curTE = $gff->next_feature;
}


## A CNS Object has the following fields: Name, Chromosome, Start, End, ORFCheck, TECheck, ConservationLevel, PositionVariability
##     

# First pass. Generate the CNS databse while merging overlapping CNS and marking TE
my $previousCNS = "";
print "\n" . localtime() . ": Collecting and merging CNS...";
while(<$CNSInputFile>) {
	my $overlapCNS = "";
	my $overlapTE;
	my $doneWithTE=0;
	my $startlog=0;
	
	chomp;
	my ($locus, $startRel, $endRel, $pval,$upordown, $chromosome, $start, $end, $orf) = split /,/;
	
	### Check for overlaps 
	if($previousCNS ne "") {
		if($CNSDB{$previousCNS}{'Chromosome'} == $chromosome && overlap($start, $end, $CNSDB{$previousCNS}{'Start'},$CNSDB{$previousCNS}{'End'})) {
			$overlapCNS = $previousCNS;
		}
	}
	
	if($markTE) {
		### first, get to the right chromosome
		while(!$doneWithTE && ($chromosome ne $curTE->seq_id)) {
			my $tmpCurTE = $gff->next_feature;
			if($tmpCurTE) {
				$curTE=$tmpCurTE;
			} else {
				$doneWithTE=1;
			}

		}
		## now get to the right place
		while(!$doneWithTE && ($chromosome eq $curTE->seq_id && $curTE->end < $start )) {
			my $tmpCurTE = $gff->next_feature;
			if($tmpCurTE) {
				$curTE=$tmpCurTE;
			} else {
				$doneWithTE=1;
			}
		}

		## If the TE is in more than 20% of the CNS, mark the overlap
		if($curTE->seq_id eq $chromosome && overlap($start, $end, $curTE->start, $curTE->end)>0.2) {
			$overlapTE=1;
		} else {
			$overlapTE=0;
		}
		
	} else {
		$overlapTE=0;
	}
	
	if($overlapCNS eq "") {
		my $newCNSName = "CNS_" . $family . "_$CNSCounter";
		$CNSDB{$newCNSName} = {
			'Name' => $newCNSName, 
			'Chromosome' => $chromosome,
			'Start' => $start,
			'End' => $end,
			'ORFCheck' => $orf,
			'TECheck' => $overlapTE,
			'ConservationLevel' => 0,
			'ConservationLevelPerLocus' => 0,
			'PositionVariability' => 0,
			'Position' => ()};
		$previousCNS = $newCNSName;
		
		push @CNSList, $newCNSName;
			
		$CNSCounter++;
	} else {
		## Merge the CNS.
		$CNSDB{$overlapCNS}{'Start'} = min($start, $CNSDB{$overlapCNS}{'Start'});
		$CNSDB{$overlapCNS}{'End'} = max($end, $CNSDB{$overlapCNS}{'End'});
		if($overlapTE == 1) {
			$CNSDB{$overlapCNS}{'TECheck'} = 1;
		}
		if($orf eq "ORF") {
			$CNSDB{$overlapCNS}{'ORFCheck'} = "ORF";
		}
		push @CNSList, $overlapCNS;
		
		$previousCNS = $overlapCNS;
	}
	if($CNSCounter % 10000 == 0 ) { print "."; }
}
print "\n" . localtime() . ": Collected " . scalar %CNSDB . " CNSs.\n";
close($CNSInputFile);

print localtime() . ": Collect positions of CNS from reference and target genomes...\n";


open ($CNSInputFile,"sort -t',' -k6,6 -k7,7n $ARGV[1] |") ||  die "ERROR: Cannot find CNS file $ARGV[1].\n";
my $CNSLineCounter =0;

while(<$CNSInputFile>) {
	chomp;
	my ($locus, $startRel, $endRel, $pval,$upordown, $chromosome, $start, $end, $orf) = split /,/;
	my $relatedCNSName = $CNSList[$CNSLineCounter];
	push (@{ $CNSDB{$relatedCNSName}{'Position'} }, {
		'Genome' => $refGenome,
		'RefLocus' => $locus,
		'TargetLocus' => $locus,
		'StartRel' => $startRel,
		'UpDown' => $upordown});
	
	my @targetPositions = @{ $mappings{$locus} };
	foreach my $curTargetPos (@{ targetPositions}) {
		if(overlap($startRel, $endRel,  $curTargetPos->{'StartRefRel'},  $curTargetPos->{'StartRefRel'} +  $curTargetPos->{'Length'})) {
			push (@{ $CNSDB{$relatedCNSName}{'Position'} }, {
				'Genome' => $curTargetPos->{'TargetGenome'},
				'RefLocus' => $locus,
				'TargetLocus' => $curTargetPos->{'TargetLocus'},
				'StartRel' => $curTargetPos->{'TargetStartRel'},
				'phyloPval' => $pval,
				'UpDown' => $upordown});
		}
	}
	
	$CNSLineCounter++;
}

print localtime() . ": Done collecting positions from reference.\n";

close ($CNSInputFile);
####### Done filtering and indexing
### Now calculate CNS level statistics
my $totalSpecies = scalar keys %targetSpecies;

foreach my $curCNS ( keys %CNSDB ) {
	my %targetGenomes;
	my $curLocus;
	my @positions = @{ $CNSDB{$curCNS}{'Position'} };
	foreach my $curTargetPos (@{ positions }) {
		$targetGenomes { $curTargetPos->{'Genome'} } =1;
		$curLocus = $curTargetPos->{'RefLocus'};
	}
	$CNSDB{$curCNS}{'ConservationLevel'} = ceil( (scalar keys %targetGenomes)/$totalSpecies*100 ) /100;
	my @speciesPerLocus = keys %{ $targetSpeciesPerLocus{$curLocus} };
	my $totalSpeciesPerLocus = scalar @speciesPerLocus; 
	$CNSDB{$curCNS}{'ConservationLevelPerLocus'} = ceil( (scalar keys %targetGenomes)/$totalSpeciesPerLocus*100 ) /100;
	### This value can be greater than 1 if the CNS is shared by more than one locus. If it is, cap at 1.
	if( $CNSDB{$curCNS}{'ConservationLevelPerLocus'} >1) {
		$CNSDB{$curCNS}{'ConservationLevelPerLocus'} = 1;
	}
	
	my @positionSum;
	foreach my $curTargetPos (@{ positions }) {
		push @positionSum, abs($curTargetPos->{'StartRel'});	
	}
	
	$CNSDB{$curCNS}{'PositionVariability'} = 0;
}


print localtime() . ": Done calculating statistics.\n";
######### Finally, dump the tables

open (my $outputCNS, ">$family.cns.table.csv");
open (my $outputPosition, ">$family.cns.position.table.csv");

foreach my $curCNS ( keys %CNSDB ) {
	print $outputCNS $family . "," .
					 $curCNS . "," .
					 $CNSDB{$curCNS}{'Chromosome'} . "," . 
					 $CNSDB{$curCNS}{'Start'} . "," .
					 $CNSDB{$curCNS}{'End'} . "," .
					 $CNSDB{$curCNS}{'ORFCheck'} . "," .
					 $CNSDB{$curCNS}{'TECheck'} . "," .
					 $CNSDB{$curCNS}{'ConservationLevel'} . "," .
					 $CNSDB{$curCNS}{'ConservationLevelPerLocus'} . "," .
					 $CNSDB{$curCNS}{'PositionVariability'} . "\n";
	my @positions = @{ $CNSDB{$curCNS}{'Position'} };
	
	#### ADD CNSID To Position file????
	foreach my $curPos ( @positions ) {
		print $outputPosition $curCNS . "," .
							  $curPos->{'RefLocus'} . "," . 
						      $curPos->{'Genome'} . "," .
						      $curPos->{'TargetLocus'} . "," .
						      $curPos->{'StartRel'} . "," .
						      $curPos->{'UpDown'} . "," . 
						      $curPos->{'phyloPval'} . "\n";	
	}
}

close($outputCNS);
close($outputPosition);


### Compute overlap between two fragments
sub overlap {
	my ($startOne, $endOne, $startTwo, $endTwo) =@_;
	if ( ($startOne < $startTwo && $endOne < $startTwo) ||
		 ($startOne > $endTwo)) {
		return 0;
	} else {
		#### return the percent overlap
		if($endOne < $endTwo) {
			if($startOne >= $startTwo) {
				return 1;
			} else {
				return ($endOne -$startTwo) /($endOne - $startOne);
			} 
		} else {
			if($startOne <= $startTwo) {
				return 1;
			} else {
				return ($endTwo -$startOne) /($endOne - $startOne);
			} 			
		}
	}
}
